<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ALIZA'S REVENGE</title>
<style>
  html,body{margin:0;height:100%;background:#070812;overflow:hidden;font-family:ui-monospace,Menlo,Consolas,monospace}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}

  .hud{
    position:fixed;left:12px;top:10px;right:12px;z-index:5;
    color:#e6f1ff; text-shadow:0 2px 0 rgba(0,0,0,.7);
    pointer-events:none; user-select:none;
    display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
  }
  .panel{
    background:rgba(0,0,0,.35);
    border:2px solid rgba(0,255,120,.32);
    padding:10px 12px; border-radius:10px;
    backdrop-filter: blur(6px);
    min-width: 230px;
  }
  .panel.r{border-color:rgba(255,80,200,.30)}
  .name{font-weight:900; letter-spacing:.12em; text-transform:uppercase; font-size:12px; opacity:.95}
  .bar{margin-top:6px; width:min(42vw,520px); height:14px; background:rgba(255,255,255,.08); border:2px solid rgba(255,255,255,.18)}
  .fill{height:100%}

  .tips{
    position:fixed;left:12px;bottom:10px;z-index:5;pointer-events:none;
    color:#c9d7ff;opacity:.92;font-size:12px;letter-spacing:.06em;
    background:rgba(0,0,0,.35);border:2px solid rgba(56,246,255,.22);border-radius:10px;padding:10px 12px;
    text-shadow:0 2px 0 rgba(0,0,0,.7);
    max-width:min(820px, calc(100vw - 24px));
  }

  .overlay{
    position:fixed;inset:0;display:grid;place-items:center;z-index:6;
    background:radial-gradient(900px 650px at 50% 40%, rgba(0,255,120,.10), rgba(56,246,255,.08), rgba(255,80,200,.06), rgba(0,0,0,.75));
    color:#e6f1ff;text-align:center;text-shadow:0 3px 0 rgba(0,0,0,.9);
  }
  .box{
    padding:18px 18px;border-radius:16px;
    background:rgba(0,0,0,.50);
    border:3px solid rgba(0,255,120,.30);
    box-shadow:0 20px 90px rgba(0,0,0,.70);
    width:min(720px,92vw);
  }
  .title{
    font-size:34px;font-weight:1000;letter-spacing:.22em;text-transform:uppercase;
    color:#00ff78;
    text-shadow:0 0 14px rgba(0,255,120,.28), 0 0 26px rgba(56,246,255,.16), 0 0 34px rgba(255,80,200,.12);
  }
  .sub{margin-top:12px;font-size:12px;letter-spacing:.14em;opacity:.92;line-height:1.6}
  .blink{animation:blink 1s steps(2,end) infinite}
  @keyframes blink{50%{opacity:.25}}
</style>
</head>
<body>

<div class="hud" id="hud">
  <div class="panel">
    <div class="name">ALIZA</div>
    <div class="bar"><div id="hp1" class="fill" style="width:100%;background:#00ff78"></div></div>
  </div>
  <div class="panel r">
    <div class="name">MUSCLE DUDE</div>
    <div class="bar"><div id="hp2" class="fill" style="width:100%;background:#ff50c8"></div></div>
  </div>
</div>

<div class="tips" id="tips">
  <b>Controls:</b> ←/→ move · ↓ duck · Z light punch · X heavy punch · A light kick · S heavy kick · R restart<br>
  <span style="opacity:.85">Tip: press ENTER to start (enables music + impact sounds).</span>
</div>

<div class="overlay" id="overlay">
  <div class="box">
    <div class="title">ALIZA'S REVENGE</div>
    <div class="sub">
      8-BIT TRIBUTE FIGHTER • SYNTHWAVE + MATRIX GREEN<br>
      <span class="blink">PRESS ENTER TO START</span><br><br>
      Move: ←/→ • Duck: ↓ • Z/X punches • A/S kicks
    </div>
  </div>
</div>

<canvas id="game"></canvas>

<script>
/* =========================
   Canvas / scale
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });

const SCALE = 3;
let W=0,H=0;
function resize(){
  const sw = innerWidth, sh = innerHeight;
  W = Math.max(320, Math.floor(sw / SCALE));
  H = Math.max(180, Math.floor(sh / SCALE));
  canvas.width = W; canvas.height = H;
}
addEventListener("resize", resize); resize();

const PAL = {
  bg0:"#070812", bg1:"#0b1030", k:"#000",
  g:"#00ff78", c:"#38f6ff", m:"#ff50c8", y:"#ffd166",
  w:"#e6f1ff", r:"#ff3355",
  hair:"#5b3a1f", hair2:"#3c2514",
  skin:"#ffcc99", tan:"#cc8855", steel:"#6f7aa5"
};

const hudEl = document.getElementById("hud");
const tipsEl = document.getElementById("tips");
const overlayEl = document.getElementById("overlay");

/* =========================
   Input
   ========================= */
const keys = new Set();
addEventListener("keydown", (e)=>{
  keys.add(e.key.toLowerCase());
  if(["arrowleft","arrowright","arrowdown"," "].includes(e.key.toLowerCase())) e.preventDefault();
});
addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));
const down = k => keys.has(k);

/* =========================
   Audio: music + impact SFX
   (Starts ONLY after Enter)
   ========================= */
let ac=null, musicTimer=null, musicOn=false;

const A4=440, m2hz=m=>A4*Math.pow(2,(m-69)/12);

function ensureAudio(){
  if(ac) return;
  ac = new (window.AudioContext||window.webkitAudioContext)();
}

function startMusic(){
  ensureAudio();
  if(musicOn) return;
  musicOn = true;

  const master = ac.createGain(); master.gain.value = 0.30;

  const sh = ac.createWaveShaper();
  sh.curve = (() => {
    const n=4096, c=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x=(i*2)/(n-1)-1;
      c[i]=Math.tanh(4.6*x);
    }
    return c;
  })();
  sh.oversample="4x";

  const lp = ac.createBiquadFilter();
  lp.type="lowpass"; lp.frequency.value = 4300; lp.Q.value = 0.8;

  const comp = ac.createDynamicsCompressor();
  comp.threshold.value=-24; comp.knee.value=14; comp.ratio.value=7;
  comp.attack.value=0.003; comp.release.value=0.16;

  master.connect(sh); sh.connect(lp); lp.connect(comp); comp.connect(ac.destination);

  // ducking bus
  const duck = ac.createGain(); duck.gain.value = 1.0;
  duck.connect(master);

  // sub + mid bass
  const subOsc = ac.createOscillator(); subOsc.type="sine";
  const subG = ac.createGain(); subG.gain.value=0.0;
  subOsc.connect(subG); subG.connect(duck); subOsc.start();

  const midOsc = ac.createOscillator(); midOsc.type="square";
  const midG = ac.createGain(); midG.gain.value=0.0;
  midOsc.connect(midG); midG.connect(duck); midOsc.start();

  // tiny dark pad (very quiet)
  const pad = ac.createOscillator(); pad.type="triangle";
  const padF = ac.createBiquadFilter(); padF.type="lowpass"; padF.frequency.value=850;
  const padG = ac.createGain(); padG.gain.value=0.0;
  pad.connect(padF); padF.connect(padG); padG.connect(master); pad.start();

  // darker hat noise
  function hat(str=0.040){
    const len=Math.floor(ac.sampleRate*0.010);
    const buf=ac.createBuffer(1,len,ac.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len,2.8);
    const src=ac.createBufferSource(); src.buffer=buf;
    const g=ac.createGain(); g.gain.value=str;
    src.connect(g); g.connect(master); src.start();
  }

  // kick + pump
  function kick(){
    const o=ac.createOscillator(); o.type="sine";
    const g=ac.createGain(); o.connect(g); g.connect(master);
    const now=ac.currentTime;
    o.frequency.setValueAtTime(120,now);
    o.frequency.exponentialRampToValueAtTime(44,now+0.10);
    g.gain.setValueAtTime(0.22,now);
    g.gain.exponentialRampToValueAtTime(0.001,now+0.13);

    duck.gain.cancelScheduledValues(now);
    duck.gain.setValueAtTime(0.34,now);
    duck.gain.exponentialRampToValueAtTime(1.0,now+0.14);

    o.start(now); o.stop(now+0.15);
  }

  // triplet-ish 12-step grid (3-beat arp feel)
  const bpm = 138;
  const secPerBeat = 60/bpm;
  const barSec = secPerBeat*4;
  const stepSec = barSec/12;
  const stepMs = Math.floor(stepSec*1000);

  const root = 38; // deep
  const arp = [
    root, root+7, root+10,
    root, root+5, root+10,
    root, root+7, root+12,
    root, root+5, root+10
  ];

  const kickSteps = new Set([0,6,9]);
  const hatSteps  = new Set([3,5,11]); // fewer highs

  let step=0;
  function tick(){
    const now=ac.currentTime;

    if(kickSteps.has(step)) kick();
    if(hatSteps.has(step)) hat(0.038 + Math.random()*0.014);

    const n = arp[step % arp.length];
    const hz = m2hz(n);
    subOsc.frequency.setTargetAtTime(hz, now, 0.010);
    midOsc.frequency.setTargetAtTime(hz, now, 0.012);

    subG.gain.setTargetAtTime(0.34, now, 0.020);
    midG.gain.setTargetAtTime(0.09, now, 0.030);

    // quiet pad on downbeats
    const padOn = (step % 12 === 0 || step % 12 === 6);
    if(padOn){
      pad.frequency.setTargetAtTime(m2hz(root+24), now, 0.05);
      padG.gain.setTargetAtTime(0.018, now, 0.10);
    } else {
      padG.gain.setTargetAtTime(0.0, now, 0.10);
    }

    lp.frequency.setTargetAtTime(3900 + Math.sin(step/6)*900, now, 0.05);

    step++;
  }
  musicTimer = setInterval(tick, stepMs);
  tick();
}

// impact SFX: short “thwack” + click
function sfxHit(heavy=false){
  if(!ac) return;
  const now = ac.currentTime;

  // thwack (noise burst)
  const len = Math.floor(ac.sampleRate * (heavy ? 0.06 : 0.045));
  const buf = ac.createBuffer(1, len, ac.sampleRate);
  const d = buf.getChannelData(0);
  for(let i=0;i<len;i++){
    const env = Math.pow(1 - i/len, 2.2);
    d[i] = (Math.random()*2-1) * env;
  }
  const src = ac.createBufferSource(); src.buffer = buf;

  const bp = ac.createBiquadFilter();
  bp.type="bandpass"; bp.frequency.value = heavy ? 320 : 520; bp.Q.value = 1.2;

  const g = ac.createGain(); g.gain.value = heavy ? 0.55 : 0.40;
  src.connect(bp); bp.connect(g); g.connect(ac.destination);
  src.start(now);

  // click (very short tone)
  const o = ac.createOscillator(); o.type="square";
  const og = ac.createGain();
  o.frequency.setValueAtTime(heavy ? 140 : 220, now);
  og.gain.setValueAtTime(0.12, now);
  og.gain.exponentialRampToValueAtTime(0.001, now + (heavy ? 0.06 : 0.04));
  o.connect(og); og.connect(ac.destination);
  o.start(now); o.stop(now + (heavy ? 0.065 : 0.045));
}

/* =========================
   Fighters
   ========================= */
const groundY = () => H - 26;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rectsOverlap = (a,b)=> a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;

class Fighter{
  constructor(opts){
    Object.assign(this,{
      name:"F",
      x:60, y:groundY()-44, w:22, h:44,
      dir:1, vx:0,
      hp:100, maxhp:100,
      duck:false,
      state:"idle",
      timer:0,
      hitDone:false,
      color1:PAL.g, color2:PAL.c, accent:PAL.m,
      skin:PAL.skin,
      hair:PAL.hair, hair2:PAL.hair2,
      feminine:false,
      power:1.0,
      flash:0
    },opts);
  }
  hurt(dmg){
    this.hp = clamp(this.hp - dmg, 0, this.maxhp);
    this.flash = 0.12;
  }
  getBodyBox(){
    const dh = this.duck ? 28 : this.h;
    const dy = this.duck ? (this.h - dh) : 0;
    return { x:this.x, y:this.y+dy, w:this.w, h:dh };
  }
  getHitBox(){
    if(!this.state.startsWith("atk")) return null;
    const b = this.getBodyBox();
    const isKick = (this.state === "atk_lk" || this.state === "atk_hk");
    const heavy  = (this.state === "atk_hp" || this.state === "atk_hk");
    const reach  = heavy ? 18 : 14;
    const hgt    = isKick ? 12 : 10;
    const yOff   = isKick ? (b.h - 14) : 12;
    return {
      x: this.dir===1 ? (b.x + b.w) : (b.x - reach),
      y: b.y + yOff,
      w: reach,
      h: hgt
    };
  }
  startAttack(kind){
    if(this.state !== "idle" && this.state !== "move") return;
    this.state = kind;
    this.timer = 0;
    this.hitDone = false;
  }
  update(dt){
    this.timer += dt;
    if(this.flash>0) this.flash = Math.max(0, this.flash - dt);

    this.y = groundY() - this.h;
    this.x += this.vx * dt;
    this.vx *= 0.82;
    this.x = clamp(this.x, 8, W - this.w - 8);

    const endAt = ({atk_lp:0.22, atk_hp:0.34, atk_lk:0.26, atk_hk:0.38})[this.state] ?? 0;
    if(endAt && this.timer >= endAt){
      this.state="idle"; this.timer=0; this.hitDone=false;
    }

    if(!this.state.startsWith("atk")) this.duck = false;
  }

  draw(){
    const b = this.getBodyBox();

    // shadow
    ctx.fillStyle="rgba(0,0,0,.45)";
    ctx.fillRect(b.x+2, groundY()-4, b.w, 6);

    // hurt flash overlay
    const flash = this.flash>0;
    const tint = flash ? "rgba(255,255,255,.25)" : null;

    // hair for feminine sprite (long brown)
    if(this.feminine){
      ctx.fillStyle = this.hair2;
      // back hair block
      ctx.fillRect(b.x+2, b.y+2, b.w-4, 18);
      ctx.fillStyle = this.hair;
      // longer strands
      ctx.fillRect(b.x+1, b.y+12, 4, b.h-10);
      ctx.fillRect(b.x+b.w-5, b.y+12, 4, b.h-10);
    }

    // torso
    ctx.fillStyle = this.color1;
    ctx.fillRect(b.x, b.y+12, b.w, b.h-16);

    // trim
    ctx.fillStyle = this.accent;
    ctx.fillRect(b.x, b.y+20, b.w, 3);

    // head
    ctx.fillStyle = this.skin;
    ctx.fillRect(b.x+4, b.y+2, b.w-8, 10);

    // glasses/visor (nerd vibe)
    ctx.fillStyle = this.color2;
    ctx.fillRect(b.x+5, b.y+6, b.w-10, 3);

    // legs
    ctx.fillStyle = this.color2;
    ctx.fillRect(b.x+2, b.y+b.h-6, b.w-4, 6);

    const atk = this.state.startsWith("atk");
    const punch = (this.state==="atk_lp"||this.state==="atk_hp");
    const kick  = (this.state==="atk_lk"||this.state==="atk_hk");
    const heavy = (this.state==="atk_hp"||this.state==="atk_hk");

    if(!atk){
      // idle arm
      ctx.fillStyle = this.skin;
      ctx.fillRect(b.x + (this.dir===1? b.w-5:2), b.y+16, 4, 10);
    } else if(punch){
      const ext = heavy ? 18 : 14;
      const armY = b.y+16;
      const armX = this.dir===1 ? b.x+b.w-4 : b.x - ext + 4;
      ctx.fillStyle = this.skin;
      ctx.fillRect(armX, armY, ext, 4);
      ctx.fillStyle = heavy ? PAL.y : PAL.w;
      ctx.fillRect(this.dir===1 ? armX+ext-4 : armX, armY-1, 4, 6);
    } else if(kick){
      const ext = heavy ? 20 : 16;
      const legY = b.y+b.h-14;
      const legX = this.dir===1 ? b.x+b.w-6 : b.x - ext + 6;
      ctx.fillStyle = this.color2;
      ctx.fillRect(legX, legY, ext, 4);
      ctx.fillStyle = heavy ? PAL.y : PAL.w;
      ctx.fillRect(this.dir===1 ? legX+ext-4 : legX, legY-1, 4, 6);
    }

    if(this.duck){
      ctx.fillStyle="rgba(0,0,0,.35)";
      ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    if(tint){
      ctx.fillStyle = tint;
      ctx.fillRect(b.x, b.y, b.w, b.h);
    }
  }
}

const aliza = new Fighter({
  name:"ALIZA",
  x:60, dir:1,
  color1:PAL.g, color2:PAL.c, accent:PAL.m,
  skin:PAL.skin, hair:PAL.hair, hair2:PAL.hair2,
  feminine:true,
  power:1.0
});

const dude = new Fighter({
  name:"DUDE",
  x:0, dir:-1,
  color1:PAL.r, color2:PAL.steel, accent:PAL.y,
  skin:PAL.tan,
  feminine:false,
  power:1.12
});

function faceEachOther(){
  aliza.dir = (aliza.x < dude.x) ? 1 : -1;
  dude.dir  = (dude.x  < aliza.x) ? 1 : -1;
}

/* =========================
   AI (simple)
   ========================= */
let aiCooldown=0;
function updateAI(dt){
  aiCooldown -= dt;
  const dist = Math.abs((dude.x+dude.w/2)-(aliza.x+aliza.w/2));

  if(dude.state==="idle"||dude.state==="move"){
    if(dist > 70){
      dude.vx += (dude.x < aliza.x ? 60 : -60) * dt;
      dude.state="move";
    } else if(dist < 44){
      dude.vx += (dude.x < aliza.x ? -40 : 40) * dt;
      dude.state="move";
    } else {
      dude.state="idle";
    }
  }

  dude.duck = false;
  if(dist < 78 && Math.random() < 0.003) dude.duck = true;

  if(aiCooldown<=0 && (dude.state==="idle"||dude.state==="move") && dist < 74){
    const r=Math.random();
    if(r<0.45) dude.startAttack("atk_lp");
    else if(r<0.65) dude.startAttack("atk_lk");
    else if(r<0.85) dude.startAttack("atk_hp");
    else dude.startAttack("atk_hk");
    aiCooldown = 0.30 + Math.random()*0.50;
  }
}

/* =========================
   Player control
   ========================= */
function updatePlayer(dt){
  if(aliza.state==="idle"||aliza.state==="move"){
    let moving=false;
    if(down("arrowleft")){ aliza.vx -= 3.6; moving=true; }
    if(down("arrowright")){ aliza.vx += 3.6; moving=true; }
    aliza.state = moving ? "move" : "idle";
  }

  if(down("arrowdown") && !aliza.state.startsWith("atk")){
    aliza.duck=true; aliza.state="idle";
  }

  if(down("z")) aliza.startAttack("atk_lp");
  if(down("x")) aliza.startAttack("atk_hp");
  if(down("a")) aliza.startAttack("atk_lk");
  if(down("s")) aliza.startAttack("atk_hk");
}

/* =========================
   Combat
   ========================= */
const sparks=[];
function addSparks(x,y,kind){
  const n = kind==="heavy" ? 10 : 7;
  for(let i=0;i<n;i++){
    sparks.push({
      x, y,
      vx:(Math.random()*2-1)*40,
      vy:(Math.random()*2-1)*30 - 10,
      t:0.18 + Math.random()*0.08,
      c: (Math.random()<0.5 ? PAL.c : PAL.m)
    });
  }
}

function tryHit(attacker, defender){
  const hb = attacker.getHitBox();
  if(!hb || attacker.hitDone) return;

  const defBox = defender.getBodyBox();
  const heavy = (attacker.state==="atk_hp"||attacker.state==="atk_hk");
  const punch = (attacker.state==="atk_lp"||attacker.state==="atk_hp");

  // ducking can cause high punches to whiff
  const missByDuck = defender.duck && punch && hb.y < defBox.y + 8;

  if(!missByDuck && rectsOverlap(hb, defBox)){
    const dmgBase = ({atk_lp:7, atk_hp:12, atk_lk:8, atk_hk:14})[attacker.state] ?? 6;
    const dmg = dmgBase * attacker.power;

    defender.hurt(dmg);
    attacker.hitDone = true;

    // knockback
    const kb = heavy ? 1.9 : 1.2;
    defender.vx += attacker.dir * kb * 3.8;

    // sparks + sfx
    addSparks(hb.x + (hb.w/2), hb.y + (hb.h/2), heavy ? "heavy" : "light");
    sfxHit(heavy);
  }
}

/* =========================
   Background / draw
   ========================= */
let t=0;

function drawBackground(){
  // sky gradient
  const grd = ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0, "#090b18");
  grd.addColorStop(0.55, "#0a1130");
  grd.addColorStop(1, "#04050a");
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,W,H);

  // floating pixels (green + synth accents)
  for(let i=0;i<120;i++){
    const px=(Math.random()*W)|0;
    const py=(Math.random()*H*0.55)|0;
    const r=Math.random();
    ctx.fillStyle = r>0.94 ? "rgba(255,80,200,.18)" : (r>0.86 ? "rgba(56,246,255,.16)" : "rgba(0,255,120,.12)");
    ctx.fillRect(px,py,1,1);
  }

  // floor
  ctx.fillStyle = "#05070f";
  ctx.fillRect(0, groundY(), W, H-groundY());

  // grid
  ctx.fillStyle = "rgba(56,246,255,.08)";
  for(let x=0;x<W;x+=12) ctx.fillRect(x, groundY(), 1, H-groundY());
  for(let y=groundY();y<H;y+=8) ctx.fillRect(0, y, W, 1);

  // horizon line
  ctx.fillStyle="rgba(0,255,120,.20)";
  ctx.fillRect(0, groundY(), W, 1);

  // tiny rain columns
  ctx.fillStyle="rgba(0,255,120,.12)";
  for(let i=0;i<26;i++){
    const cx = (i*15 + ((t*45)|0)) % W;
    const len = 6 + (i%9);
    for(let j=0;j<len;j++){
      const yy = (((t*70)|0) + i*11 + j*8) % (groundY()-6);
      ctx.fillRect(cx, yy, 1, 3);
    }
  }

  // title text on top-left (pixel vibe)
  ctx.font="10px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillStyle="rgba(0,0,0,.35)";
  ctx.fillRect(10, 44, 250, 18);
  ctx.strokeStyle="rgba(0,255,120,.30)";
  ctx.strokeRect(10, 44, 250, 18);
  ctx.fillStyle="rgba(0,255,120,.92)";
  ctx.fillText("ALIZA'S REVENGE  //  8-BIT TRIBUTE", 16, 56);
}

function drawSparks(dt){
  for(let i=sparks.length-1;i>=0;i--){
    const s=sparks[i];
    s.t -= dt;
    s.x += s.vx*dt;
    s.y += s.vy*dt;
    s.vy += 30*dt;
    ctx.fillStyle = s.c;
    ctx.fillRect(s.x|0, s.y|0, 1, 1);
    if(s.t<=0) sparks.splice(i,1);
  }
}

/* =========================
   Game state
   ========================= */
const hp1 = document.getElementById("hp1");
const hp2 = document.getElementById("hp2");

let state="title";
let over=false;
let last=performance.now();

function restart(){
  over=false;
  aliza.hp=aliza.maxhp; dude.hp=dude.maxhp;
  aliza.x=60; dude.x=W-90;
  aliza.vx=dude.vx=0;
  aliza.state=dude.state="idle";
  aliza.duck=dude.duck=false;
  aiCooldown=0.25;
  sparks.length=0;
  hp1.style.width="100%";
  hp2.style.width="100%";
  state="fight";
}

function begin(){
  // enter gesture: enable audio
  startMusic();
  overlayEl.style.display="none";
  hudEl.style.display="flex";
  tipsEl.style.display="block";
  state="fight";
  // place dude relative to current width
  dude.x = W - 90;
}

addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="enter" && state==="title") begin();
  if(k==="r" && state!=="title") restart();
});

function loop(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last=now;
  t += dt;

  // keep opponent in-bounds when resized
  dude.x = clamp(dude.x, 8, W - dude.w - 8);

  // update
  if(state==="fight" && !over){
    updatePlayer(dt);
    updateAI(dt);

    faceEachOther();
    aliza.update(dt);
    dude.update(dt);

    // keep them from overlapping too much
    const dx = (dude.x - aliza.x);
    const minDist = 18;
    if(Math.abs(dx) < minDist){
      const push=(minDist - Math.abs(dx))*0.5;
      aliza.x -= Math.sign(dx)*push;
      dude.x  += Math.sign(dx)*push;
    }

    // hits (this is the main fix)
    tryHit(aliza, dude);
    tryHit(dude, aliza);

    // HUD
    hp1.style.width = (aliza.hp/aliza.maxhp*100).toFixed(1)+"%";
    hp2.style.width = (dude.hp/dude.maxhp*100).toFixed(1)+"%";

    if(aliza.hp<=0 || dude.hp<=0){
      over=true;
      state="ko";
      overlayEl.style.display="grid";
      overlayEl.querySelector(".title").textContent = (dude.hp<=0) ? "ALIZA WINS" : "KO";
      overlayEl.querySelector(".sub").innerHTML =
        `PRESS R TO RESTART<br><br><span style="opacity:.9">Music & SFX stay on.</span>`;
    }
  }

  // render
  drawBackground();
  if(state!=="title"){
    aliza.draw();
    dude.draw();
    drawSparks(dt);
  }

  requestAnimationFrame(loop);
}
hudEl.style.display="none";
tipsEl.style.display="none";
requestAnimationFrame(loop);
</script>
</body>
</html>
